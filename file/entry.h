///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2013-2014 Dimitry Ishenko
// Distributed under the GNU GPL v2. For full terms please visit:
// http://www.gnu.org/licenses/gpl.html
//
// Contact: dimitry (dot) ishenko (at) (gee) mail (dot) com

///////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef ENTRY_H
#define ENTRY_H

///////////////////////////////////////////////////////////////////////////////////////////////////
#include "file.h"
#include "errno_error.h"

#include <functional>
#include <vector>
#include <string>
#include <dirent.h>

///////////////////////////////////////////////////////////////////////////////////////////////////
namespace storage
{

///////////////////////////////////////////////////////////////////////////////////////////////////
struct entry;
typedef std::vector<entry> entries;

typedef std::function<bool(const entry&)> filter_func;
typedef std::function<int(const entry&, const entry&)> compare_func;

///////////////////////////////////////////////////////////////////////////////////////////////////
extern const filter_func filter_all;
extern const compare_func compare_version;
extern const compare_func compare_alpha;

///////////////////////////////////////////////////////////////////////////////////////////////////
enum class type
{
    block=   DT_BLK,
    chr=     DT_CHR,
    dir=     DT_DIR,
    fifo=    DT_FIFO,
    link=    DT_LNK,
    file=    DT_REG,
    sock=    DT_SOCK,
    unknown= DT_UNKNOWN
};

inline type get_type(const std::string& name) { return static_cast<type>((mode(name) & S_IFMT) >> 12); }

///////////////////////////////////////////////////////////////////////////////////////////////////
struct entry
{
    static entries get(const std::string& path, const filter_func& filter= filter_all,
                                                const compare_func& compare= compare_version);

    std::string name;
    storage::type type;

    ino_t inode;
};

///////////////////////////////////////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////////////////////////////////////
#endif // ENTRY_H
