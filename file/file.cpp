///////////////////////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2013 Dimitry Ishenko
// Distributed under the GNU GPL v2. For full terms please visit:
// http://www.gnu.org/licenses/gpl.html
//
// Contact: dimitry (dot) ishenko (at) (gee) mail (dot) com

///////////////////////////////////////////////////////////////////////////////////////////////////
#include "file.h"

#include <memory>

#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/select.h>
#include <limits.h> // PATH_MAX

///////////////////////////////////////////////////////////////////////////////////////////////////
namespace file
{

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
void file::open(const std::string& name, open_flags flags, perm p)
{
    int mode= flags & ~open::read_write;
    if(flags.contains(open::read_write))
        mode|= O_RDWR;
    else if(flags.contains(open::write))
        mode|= O_WRONLY;
    else mode|= O_RDONLY;

    _M_fd= ::open(name.data(), mode, p);
    if(_M_fd == invalid_desc) throw system_except();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void file::close()
{
    if(!(_M_fd==0 || _M_fd==1 || _M_fd==2) && is_open())
    {
        ::close(_M_fd);
        _M_fd= invalid_desc;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
ssize_t file::write(const std::string& value)
{
    return write(value.data(), value.size());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
ssize_t file::write(const void* p, size_t n)
{
    ssize_t l= ::write(_M_fd, p, n);
    if(l == -1) throw system_except();

    return l;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
ssize_t file::read(std::string& value, size_t max, bool wait)
{
    std::unique_ptr<char[]> buffer(new char[max+1]);
    ssize_t num= read(buffer.get(), max, wait);
    buffer[num]=0;

    value.assign(buffer.get(), num);
    return num;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
ssize_t file::read(void* pointer, size_t max, bool wait)
{
    ssize_t num=0;
    if(wait || can_read()) num= ::read(_M_fd, pointer, max);

    if(num == -1) throw system_except();
    return num;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
off_t file::seek(off_t value, origin o)
{
    off_t f= ::lseek(_M_fd, value, int(o));
    if(f == -1) throw system_except();

    return f;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
off_t file::size()
{
    off_t n= tell();
    off_t e= seek(0, origin::end);

    seek(n);
    return e;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool file::can_read(timeval* tv)
{
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(_M_fd, &fds);

    int n= select(_M_fd+1, &fds, 0, 0, tv);
    if(n == -1) throw system_except();

    return n;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool file::can_write(timeval* tv)
{
    fd_set fds;
    FD_ZERO(&fds);
    FD_SET(_M_fd, &fds);

    int n= select(_M_fd+1, 0, &fds, 0, tv);
    if(n == -1) throw system_except();

    return n;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool file::stat(struct stat& buf)
{
    return ::fstat(_M_fd, &buf)==0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
mode_t file::mode()
{
    struct stat buf;
    return stat(buf)? buf.st_mode: 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void file::chown(uid_t uid, gid_t gid)
{
    if(fchown(_M_fd, uid, gid)) throw system_except();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
void remove(const std::string& name)
{
    if( ::remove(name.data()) ) throw system_except();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void rename(const std::string& prev, const std::string& name)
{
    if(::rename(prev.data(), name.data())) throw system_except();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
std::string real_path(const std::string& path)
{
    std::unique_ptr<char[]> buffer(new char[PATH_MAX]);
    std::string real;

    if(::realpath(path.data(), buffer.get()))
        real.assign(buffer.get());
    else throw system_except();

    return real;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool stat(const std::string& name, struct stat& buf)
{
    return ::stat(name.data(), &buf)==0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void chown(const std::string& name, uid_t uid, gid_t gid, bool deref)
{
    if( (deref? ::chown(name.data(), uid, gid): lchown(name.data(), uid, gid)) ) throw system_except();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
mode_t mode(const std::string& name)
{
    struct stat buf;
    return stat(name, buf)? buf.st_mode: 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
}
