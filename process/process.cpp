///////////////////////////////////////////////////////////////////////////////////////////////////
#include "process.h"
#include "errno_error.h"

#include <memory>
#include <cstdlib>

#include <sys/types.h>
#include <unistd.h>

///////////////////////////////////////////////////////////////////////////////////////////////////
namespace app
{

///////////////////////////////////////////////////////////////////////////////////////////////////
void process::_M_process(std::function<int()> func)
{
    _M_id= fork();
    if(_M_id == -1) throw errno_error();

    if(_M_id == 0)
    {
        int code= func();
        exit(code);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
namespace this_process
{

///////////////////////////////////////////////////////////////////////////////////////////////////
process::id get_id() noexcept
{
    return getpid();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
process::id parent_id() noexcept
{
    return getppid();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
struct aren_deleter
{
    void operator()(char* args[])
    {
        for(char* arg= args[0]; arg; ++arg) free(arg);
        delete[] args;
    }
};

typedef std::unique_ptr<char*[], aren_deleter> aren_ptr;

///////////////////////////////////////////////////////////////////////////////////////////////////
static aren_ptr create_arg(const std::string& path, std::initializer_list<std::string> args)
{
    aren_ptr value(new char*[args.size()+2]);

    int ri=0;
    value[ri++]= strdup(path.data());

    for(const std::string& x: args) value[ri++]= strdup(x.data());
    value[ri]= nullptr;

    return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
static aren_ptr create_env(const app::environment& env)
{
    aren_ptr value(new char*[env.size()+1]);

    int ri=0;
    for(auto& x: env) value[ri++]= strdup((x.first+ "="+ x.second).data());
    value[ri]= nullptr;

    return value;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
void replace(const std::string& path, std::initializer_list<std::string> args)
{
    aren_ptr arg= create_arg(path, args);

    if(execv(arg[0], arg.get())) throw errno_error();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void replace(const std::string& path, const app::environment& e, std::initializer_list<std::string> args)
{
    aren_ptr arg= create_arg(path, args);
    aren_ptr env= create_env(e);

    if(execve(arg[0], arg.get(), env.get())) throw errno_error();
}

///////////////////////////////////////////////////////////////////////////////////////////////////
int execute(const std::string& command, app::signal* signal)
{
    int code= system(command.data());
    switch(code)
    {
    case  -1: throw execute_error("app::execute failed");
    case 127: throw execute_error("Could not execute shell in the child process");

    default:
        if(WIFEXITED(code)) return WEXITSTATUS(code);

        if(WIFSIGNALED(code) && signal)
            *signal= static_cast<app::signal>(WTERMSIG(code));
        return -1;
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
}

///////////////////////////////////////////////////////////////////////////////////////////////////
}
